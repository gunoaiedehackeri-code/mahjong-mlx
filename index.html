<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mahjong MLX - Firebase Secure</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
    <style>
        body { margin: 0; padding: 0; font-family: system-ui, -apple-system, sans-serif; }
        .tile-3d { position: absolute; transition: all 0.3s; cursor: pointer; user-select: none; }
        .tile-3d:hover:not(.matched):not(.blocked) { transform: translateY(-5px); filter: brightness(1.1); }
        .tile-face {
            background: linear-gradient(145deg, #ffffff, #f5f5f5);
            border: 2px solid #8b7355;
            border-radius: 6px;
            box-shadow: 2px 2px 6px rgba(0,0,0,0.3), inset 1px 1px 2px rgba(255,255,255,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .tile-selected { background: linear-gradient(145deg, #fef3c7, #fde68a) !important; transform: translateY(-3px) scale(1.03); }
        .tile-blocked { opacity: 0.5; cursor: not-allowed; }
        .tile-matched { opacity: 0; pointer-events: none; }
        .tile-removal-mode { border: 3px solid #ef4444 !important; animation: pulse-red 1s infinite; }
        @keyframes pulse-red { 0%, 100% { box-shadow: 0 0 10px #ef4444; } 50% { box-shadow: 0 0 20px #ef4444; } }
        .tile-will-remove { background: linear-gradient(145deg, #fca5a5, #ef4444) !important; border-color: #dc2626 !important; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const firebaseConfig = {
            apiKey: "AIzaSyD5xxJY8e3SBnqilGWTi4wNVP122A3QwGs",
            authDomain: "mlx-majong.firebaseapp.com",
            projectId: "mlx-majong",
            storageBucket: "mlx-majong.firebasestorage.app",
            messagingSenderId: "94760449277",
            appId: "1:94760439277:web:db73308fbc348d08c6ebe4"
        };
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const EMAILJS_SERVICE_ID = 'service_pta9wmt';
        const EMAILJS_TEMPLATE_ID = 'template_iqxpxuk';
        const EMAILJS_PUBLIC_KEY = 'pWixVv62QrlwjPZAm';
        const { useState, useEffect } = React;
        const MahjongMLX = () => {
const [gameState, setGameState] = useState('login');
            const [user, setUser] = useState(null);
            const [level, setLevel] = useState(1);
            const [mmlxBalance, setMmlxBalance] = useState(0);
            const [tiles, setTiles] = useState([]);
            const [selectedTiles, setSelectedTiles] = useState([]);
            const [startTime, setStartTime] = useState(null);
            const [elapsedTime, setElapsedTime] = useState(0);
            const [completedLevels, setCompletedLevels] = useState(0);
            const [username, setUsername] = useState('');
            const [password, setPassword] = useState('');
            const [isLogin, setIsLogin] = useState(true);
            const [exchangeRate, setExchangeRate] = useState(100000);
            const [isAdmin, setIsAdmin] = useState(false);
            const [hint, setHint] = useState('');
            const [loading, setLoading] = useState(false);
            const [showAd, setShowAd] = useState(false);
            const [adPurpose, setAdPurpose] = useState('');
            const [isRemovalMode, setIsRemovalMode] = useState(false);
            const [removalPreview, setRemovalPreview] = useState([]);
            const [adRemovalsUsed, setAdRemovalsUsed] = useState(0);
            const [adRemovalCooldown, setAdRemovalCooldown] = useState(0);
            const [maxAdRemovalsPerLevel, setMaxAdRemovalsPerLevel] = useState(2);
            const [adFrequency, setAdFrequency] = useState(3);
            const [adsEnabled, setAdsEnabled] = useState(true);
            const [adCountdown, setAdCountdown] = useState(5);
            const [adForCoinsUsed, setAdForCoinsUsed] = useState(false);
            const [mmlxPerAd, setMmlxPerAd] = useState(500);
            const [mlxAddress, setMlxAddress] = useState('');
            const [tangledUsername, setTangledUsername] = useState('');
            const [showTangledPrompt, setShowTangledPrompt] = useState(false);

            useEffect(() => {
                const unsubscribe = auth.onAuthStateChanged(async (firebaseUser) => {
                    if (firebaseUser) {
                        const userDoc = await db.collection('users').doc(firebaseUser.uid).get();
                        if (userDoc.exists) {
                            const userData = userDoc.data();
                            setUser({ uid: firebaseUser.uid, email: firebaseUser.email, username: userData.username });
                            setMmlxBalance(userData.mmlxBalance || 0);
                            setLevel(userData.level || 1);
                            setCompletedLevels(userData.completedLevels || 0);
                            setMlxAddress(userData.mlxAddress || '');
                            setTangledUsername(userData.tangledUsername || '');
                            setGameState('menu');
                        }
                    } else {
                        setUser(null);
                        setGameState('login');
                    }
                });
                return () => unsubscribe();
            }, []);

            const getTileSets = (lvl) => {
                const basic = ['🀄', '🎋', '🎍', '🌸', '🌺', '🌻', '🌼', '🌷'];
                if (lvl >= 15) return [...basic, ...['🏵️', '🌹', '🥀', '🪷']];
                return basic;
            };

            const getLayout = (lvl) => {
                if (lvl === 1) return [{x:1,y:1,z:0},{x:2,y:1,z:0},{x:3,y:1,z:0},{x:4,y:1,z:0},{x:1,y:2,z:0},{x:2,y:2,z:0},{x:3,y:2,z:0},{x:4,y:2,z:0},{x:2,y:1,z:1},{x:3,y:1,z:1},{x:2,y:2,z:1},{x:3,y:2,z:1}];
                if (lvl >= 2 && lvl <= 4) {
                    const base = [{x:2,y:1,z:0},{x:3,y:1,z:0},{x:4,y:1,z:0},{x:5,y:1,z:0},{x:1,y:2,z:0},{x:2,y:2,z:0},{x:3,y:2,z:0},{x:4,y:2,z:0},{x:5,y:2,z:0},{x:6,y:2,z:0},{x:2,y:3,z:0},{x:3,y:3,z:0},{x:4,y:3,z:0},{x:5,y:3,z:0},{x:3,y:1,z:1},{x:4,y:1,z:1},{x:3,y:2,z:1},{x:4,y:2,z:1}];
                    if (lvl >= 3) base.push({x:2,y:2,z:1},{x:5,y:2,z:1});
                    if (lvl >= 4) base.push({x:3,y:3,z:1},{x:4,y:3,z:1});
                    return base;
                }
                if (lvl >= 5 && lvl <= 10) return [{x:2,y:0,z:0},{x:3,y:0,z:0},{x:4,y:0,z:0},{x:5,y:0,z:0},{x:6,y:0,z:0},{x:1,y:1,z:0},{x:2,y:1,z:0},{x:3,y:1,z:0},{x:4,y:1,z:0},{x:5,y:1,z:0},{x:6,y:1,z:0},{x:7,y:1,z:0},{x:0,y:2,z:0},{x:1,y:2,z:0},{x:2,y:2,z:0},{x:3,y:2,z:0},{x:4,y:2,z:0},{x:5,y:2,z:0},{x:6,y:2,z:0},{x:7,y:2,z:0},{x:8,y:2,z:0},{x:1,y:3,z:0},{x:2,y:3,z:0},{x:3,y:3,z:0},{x:4,y:3,z:0},{x:5,y:3,z:0},{x:6,y:3,z:0},{x:7,y:3,z:0},{x:2,y:4,z:0},{x:3,y:4,z:0},{x:4,y:4,z:0},{x:5,y:4,z:0},{x:6,y:4,z:0},{x:2,y:1,z:1},{x:3,y:1,z:1},{x:4,y:1,z:1},{x:5,y:1,z:1},{x:6,y:1,z:1},{x:2,y:2,z:1},{x:3,y:2,z:1},{x:4,y:2,z:1},{x:5,y:2,z:1},{x:6,y:2,z:1},{x:2,y:3,z:1},{x:3,y:3,z:1},{x:4,y:3,z:1},{x:5,y:3,z:1},{x:6,y:3,z:1},{x:3,y:2,z:2},{x:4,y:2,z:2},{x:5,y:2,z:2}];
                if (lvl >= 11 && lvl <= 20) return [{x:3,y:0,z:0},{x:4,y:0,z:0},{x:5,y:0,z:0},{x:6,y:0,z:0},{x:7,y:0,z:0},{x:2,y:1,z:0},{x:3,y:1,z:0},{x:4,y:1,z:0},{x:5,y:1,z:0},{x:6,y:1,z:0},{x:7,y:1,z:0},{x:8,y:1,z:0},{x:1,y:2,z:0},{x:2,y:2,z:0},{x:3,y:2,z:0},{x:4,y:2,z:0},{x:5,y:2,z:0},{x:6,y:2,z:0},{x:7,y:2,z:0},{x:8,y:2,z:0},{x:9,y:2,z:0},{x:1,y:3,z:0},{x:2,y:3,z:0},{x:3,y:3,z:0},{x:4,y:3,z:0},{x:5,y:3,z:0},{x:6,y:3,z:0},{x:7,y:3,z:0},{x:8,y:3,z:0},{x:9,y:3,z:0},{x:2,y:4,z:0},{x:3,y:4,z:0},{x:4,y:4,z:0},{x:5,y:4,z:0},{x:6,y:4,z:0},{x:7,y:4,z:0},{x:8,y:4,z:0},{x:3,y:5,z:0},{x:4,y:5,z:0},{x:5,y:5,z:0},{x:6,y:5,z:0},{x:7,y:5,z:0},{x:3,y:1,z:1},{x:4,y:1,z:1},{x:5,y:1,z:1},{x:6,y:1,z:1},{x:7,y:1,z:1},{x:2,y:2,z:1},{x:3,y:2,z:1},{x:4,y:2,z:1},{x:5,y:2,z:1},{x:6,y:2,z:1},{x:7,y:2,z:1},{x:8,y:2,z:1},{x:2,y:3,z:1},{x:3,y:3,z:1},{x:4,y:3,z:1},{x:5,y:3,z:1},{x:6,y:3,z:1},{x:7,y:3,z:1},{x:8,y:3,z:1},{x:3,y:4,z:1},{x:4,y:4,z:1},{x:5,y:4,z:1},{x:6,y:4,z:1},{x:7,y:4,z:1},{x:4,y:1,z:2},{x:5,y:1,z:2},{x:6,y:1,z:2},{x:3,y:2,z:2},{x:4,y:2,z:2},{x:5,y:2,z:2},{x:6,y:2,z:2},{x:7,y:2,z:2},{x:3,y:3,z:2},{x:4,y:3,z:2},{x:5,y:3,z:2},{x:6,y:3,z:2},{x:7,y:3,z:2},{x:4,y:4,z:2},{x:5,y:4,z:2},{x:6,y:4,z:2},{x:4,y:2,z:3},{x:5,y:2,z:3},{x:6,y:2,z:3},{x:4,y:3,z:3},{x:5,y:3,z:3},{x:6,y:3,z:3}];
                return [{x:4,y:0,z:0},{x:5,y:0,z:0},{x:6,y:0,z:0},{x:7,y:0,z:0},{x:8,y:0,z:0},{x:9,y:0,z:0},{x:3,y:1,z:0},{x:4,y:1,z:0},{x:5,y:1,z:0},{x:6,y:1,z:0},{x:7,y:1,z:0},{x:8,y:1,z:0},{x:9,y:1,z:0},{x:10,y:1,z:0},{x:2,y:2,z:0},{x:3,y:2,z:0},{x:4,y:2,z:0},{x:5,y:2,z:0},{x:6,y:2,z:0},{x:7,y:2,z:0},{x:8,y:2,z:0},{x:9,y:2,z:0},{x:10,y:2,z:0},{x:11,y:2,z:0},{x:1,y:3,z:0},{x:2,y:3,z:0},{x:3,y:3,z:0},{x:4,y:3,z:0},{x:5,y:3,z:0},{x:6,y:3,z:0},{x:7,y:3,z:0},{x:8,y:3,z:0},{x:9,y:3,z:0},{x:10,y:3,z:0},{x:11,y:3,z:0},{x:12,y:3,z:0},{x:1,y:4,z:0},{x:2,y:4,z:0},{x:3,y:4,z:0},{x:4,y:4,z:0},{x:5,y:4,z:0},{x:6,y:4,z:0},{x:7,y:4,z:0},{x:8,y:4,z:0},{x:9,y:4,z:0},{x:10,y:4,z:0},{x:11,y:4,z:0},{x:12,y:4,z:0},{x:2,y:5,z:0},{x:3,y:5,z:0},{x:4,y:5,z:0},{x:5,y:5,z:0},{x:6,y:5,z:0},{x:7,y:5,z:0},{x:8,y:5,z:0},{x:9,y:5,z:0},{x:10,y:5,z:0},{x:11,y:5,z:0},{x:3,y:6,z:0},{x:4,y:6,z:0},{x:5,y:6,z:0},{x:6,y:6,z:0},{x:7,y:6,z:0},{x:8,y:6,z:0},{x:9,y:6,z:0},{x:10,y:6,z:0},{x:4,y:1,z:1},{x:5,y:1,z:1},{x:6,y:1,z:1},{x:7,y:1,z:1},{x:8,y:1,z:1},{x:9,y:1,z:1},{x:3,y:2,z:1},{x:4,y:2,z:1},{x:5,y:2,z:1},{x:6,y:2,z:1},{x:7,y:2,z:1},{x:8,y:2,z:1},{x:9,y:2,z:1},{x:10,y:2,z:1},{x:2,y:3,z:1},{x:3,y:3,z:1},{x:4,y:3,z:1},{x:5,y:3,z:1},{x:6,y:3,z:1},{x:7,y:3,z:1},{x:8,y:3,z:1},{x:9,y:3,z:1},{x:10,y:3,z:1},{x:11,y:3,z:1},{x:2,y:4,z:1},{x:3,y:4,z:1},{x:4,y:4,z:1},{x:5,y:4,z:1},{x:6,y:4,z:1},{x:7,y:4,z:1},{x:8,y:4,z:1},{x:9,y:4,z:1},{x:10,y:4,z:1},{x:11,y:4,z:1},{x:3,y:5,z:1},{x:4,y:5,z:1},{x:5,y:5,z:1},{x:6,y:5,z:1},{x:7,y:5,z:1},{x:8,y:5,z:1},{x:9,y:5,z:1},{x:10,y:5,z:1},{x:4,y:2,z:2},{x:5,y:2,z:2},{x:6,y:2,z:2},{x:7,y:2,z:2},{x:8,y:2,z:2},{x:9,y:2,z:2},{x:3,y:3,z:2},{x:4,y:3,z:2},{x:5,y:3,z:2},{x:6,y:3,z:2},{x:7,y:3,z:2},{x:8,y:3,z:2},{x:9,y:3,z:2},{x:10,y:3,z:2},{x:3,y:4,z:2},{x:4,y:4,z:2},{x:5,y:4,z:2},{x:6,y:4,z:2},{x:7,y:4,z:2},{x:8,y:4,z:2},{x:9,y:4,z:2},{x:10,y:4,z:2},{x:4,y:5,z:2},{x:5,y:5,z:2},{x:6,y:5,z:2},{x:7,y:5,z:2},{x:8,y:5,z:2},{x:9,y:5,z:2},{x:5,y:2,z:3},{x:6,y:2,z:3},{x:7,y:2,z:3},{x:8,y:2,z:3},{x:4,y:3,z:3},{x:5,y:3,z:3},{x:6,y:3,z:3},{x:7,y:3,z:3},{x:8,y:3,z:3},{x:9,y:3,z:3},{x:4,y:4,z:3},{x:5,y:4,z:3},{x:6,y:4,z:3},{x:7,y:4,z:3},{x:8,y:4,z:3},{x:9,y:4,z:3},{x:5,y:5,z:3},{x:6,y:5,z:3},{x:7,y:5,z:3},{x:8,y:5,z:3},{x:5,y:3,z:4},{x:6,y:3,z:4},{x:7,y:3,z:4},{x:8,y:3,z:4},{x:5,y:4,z:4},{x:6,y:4,z:4},{x:7,y:4,z:4},{x:8,y:4,z:4}];
            };

            const generateTiles = (lvl) => {
                const layout = getLayout(lvl);
                const tileSet = getTileSets(lvl);
                const tiles = [];
                const pairsNeeded = Math.ceil(layout.length / 2);
                for (let i = 0; i < pairsNeeded; i++) {
                    const type = tileSet[i % tileSet.length];
                    tiles.push(type, type);
                }
                const shuffled = tiles.sort(() => Math.random() - 0.5);
                return layout.map((pos, idx) => ({ id: idx, type: shuffled[idx], x: pos.x, y: pos.y, z: pos.z, matched: false }));
            };

            const isTileBlocked = (tile, allTiles) => {
                const hasTileOnTop = allTiles.some(t => {
                    if (t.matched || t.z <= tile.z) return false;
                    const overlapX = !(t.x > tile.x + 0.5 || t.x < tile.x - 0.5);
                    const overlapY = !(t.y > tile.y + 0.5 || t.y < tile.y - 0.5);
                    return overlapX && overlapY;
                });
                if (hasTileOnTop) return true;
                const leftBlocked = allTiles.some(t => !t.matched && t.z === tile.z && t.y === tile.y && t.x === tile.x - 1);
                const rightBlocked = allTiles.some(t => !t.matched && t.z === tile.z && t.y === tile.y && t.x === tile.x + 1);
                return leftBlocked && rightBlocked;
            };

            const getTileRemovalStack = (clickedTile, allTiles) => {
                const toRemove = [clickedTile.id];
                for (let z = clickedTile.z - 1; z >= 0; z--) {
                    const tileBelow = allTiles.find(t => !t.matched && t.x === clickedTile.x && t.y === clickedTile.y && t.z === z);
                    if (tileBelow) toRemove.push(tileBelow.id);
                }
                return toRemove;
            };

            const watchAdForRemoval = () => {
                if (adRemovalCooldown > 0) { setHint(`Wait ${adRemovalCooldown}s`); setTimeout(() => setHint(''), 2000); return; }
                if (adRemovalsUsed >= maxAdRemovalsPerLevel) { setHint(`Max ${maxAdRemovalsPerLevel} per level`); setTimeout(() => setHint(''), 2000); return; }
                setAdPurpose('tileRemoval'); setAdCountdown(5); setShowAd(true);
            };
            
            const watchAdForCoins = () => {
                if (adForCoinsUsed) { setHint('Already used!'); setTimeout(() => setHint(''), 2000); return; }
                setAdPurpose('earnCoins'); setAdCountdown(5); setShowAd(true);
            };

            const closeAdAndActivateRemoval = async () => {
                setShowAd(false);
                if (adPurpose === 'tileRemoval') { setIsRemovalMode(true); setAdRemovalsUsed(prev => prev + 1); setAdRemovalCooldown(30); setHint('Click tile to remove!'); } 
                else if (adPurpose === 'earnCoins') { const newBalance = mmlxBalance + mmlxPerAd; setMmlxBalance(newBalance); setAdForCoinsUsed(true); if (user) await db.collection('users').doc(user.uid).update({ mmlxBalance: newBalance }); setHint(`Earned ${mmlxPerAd} MMLX!`); setTimeout(() => setHint(''), 3000); } 
                else if (adPurpose === 'levelComplete') { setLevel(prev => prev + 1); setGameState('menu'); }
            };

            const handleRemovalClick = (tile) => {
                if (!isRemovalMode) return;
                const toRemove = getTileRemovalStack(tile, tiles);
                setTiles(prev => { const newTiles = prev.map(t => toRemove.includes(t.id) ? {...t, matched: true} : t); setTimeout(() => { if (newTiles.every(t => t.matched)) completeLevel(); }, 500); return newTiles; });
                setIsRemovalMode(false); setRemovalPreview([]); setHint(`Removed ${toRemove.length} tile(s)!`); setTimeout(() => setHint(''), 2000);
            };

            const handleRemovalHover = (tile) => { if (isRemovalMode) setRemovalPreview(getTileRemovalStack(tile, tiles)); };

            useEffect(() => { if (adRemovalCooldown > 0) { const timer = setTimeout(() => setAdRemovalCooldown(prev => prev - 1), 1000); return () => clearTimeout(timer); } }, [adRemovalCooldown]);
            useEffect(() => { if (showAd && adCountdown > 0) { const timer = setTimeout(() => setAdCountdown(prev => prev - 1), 1000); return () => clearTimeout(timer); } }, [showAd, adCountdown]);

            const startLevel = () => { setTiles(generateTiles(level)); setSelectedTiles([]); setStartTime(Date.now()); setElapsedTime(0); setHint(''); setAdRemovalsUsed(0); setAdRemovalCooldown(0); setIsRemovalMode(false); setRemovalPreview([]); setAdForCoinsUsed(false); setGameState('playing'); };

            useEffect(() => { if (gameState === 'playing' && startTime) { const timer = setInterval(() => setElapsedTime(Math.floor((Date.now() - startTime) / 1000)), 1000); return () => clearInterval(timer); } }, [gameState, startTime]);

            const selectTile = (tile) => {
                if (isRemovalMode) { handleRemovalClick(tile); return; }
                if (tile.matched || isTileBlocked(tile, tiles)) { setHint('Blocked!'); setTimeout(() => setHint(''), 2000); return; }
                if (selectedTiles.find(t => t.id === tile.id)) { setSelectedTiles(selectedTiles.filter(t => t.id !== tile.id)); return; }
                const newSelected = [...selectedTiles, tile];
                setSelectedTiles(newSelected);
                if (newSelected.length === 2) {
                    if (newSelected[0].type === newSelected[1].type) {
                        setTimeout(() => { setTiles(prev => prev.map(t => t.id === newSelected[0].id || t.id === newSelected[1].id ? { ...t, matched: true } : t)); setSelectedTiles([]); if (tiles.every(t => t.matched || t.id === newSelected[0].id || t.id === newSelected[1].id)) completeLevel(); }, 300);
                    } else { setHint('No match!'); setTimeout(() => { setSelectedTiles([]); setHint(''); }, 1000); }
                }
            };

            const completeLevel = async () => {
                const timeTaken = elapsedTime;
                const timeBonus = Math.max(0, 180 - timeTaken);
                const baseReward = 1000 + (level * 100);
                const bonusReward = Math.floor((timeBonus / 180) * (2000 + level * 200));
                const totalReward = baseReward + bonusReward;
                const newBalance = mmlxBalance + totalReward;
                setMmlxBalance(newBalance); setCompletedLevels(prev => prev + 1);
                if (user) await db.collection('users').doc(user.uid).update({ mmlxBalance: newBalance, level: level + 1, completedLevels: completedLevels + 1, mlxAddress, tangledUsername });
                alert(`Level Complete!\n\nTime: ${timeTaken}s\nBase: ${baseReward.toLocaleString()} MMLX\nBonus: ${bonusReward.toLocaleString()} MMLX\nTotal: ${totalReward.toLocaleString()} MMLX`);
                if (adsEnabled && level % adFrequency === 0) { setAdPurpose('levelComplete'); setAdCountdown(5); setShowAd(true); } else { setLevel(prev => prev + 1); setGameState('menu'); }
            };

            const handleAuth = async () => {
                if (!username || !password) { alert('Enter username and password'); return; }
                setLoading(true);
                try {
                    if (isLogin) await auth.signInWithEmailAndPassword(username + '@mahjong-mlx.app', password);
                    else { const userCredential = await auth.createUserWithEmailAndPassword(username + '@mahjong-mlx.app', password); await db.collection('users').doc(userCredential.user.uid).set({ username, mmlxBalance: 0, level: 1, completedLevels: 0, mlxAddress: '', tangledUsername: '', createdAt: new Date().toISOString() }); }
                } catch (error) {
                    if (error.code === 'auth/user-not-found') alert('User not found. Please register first.');
                    else if (error.code === 'auth/wrong-password') alert('Incorrect password.');
                    else if (error.code === 'auth/email-already-in-use') alert('Username already exists.');
                    else alert('Error: ' + error.message);
                    setLoading(false);
                }
            };
const handleExchange = async () => {
                if (mmlxBalance < 10000) { alert('Minimum: 10,000 MMLX'); return; }
                if (!mlxAddress && !tangledUsername) { alert('Add payment info in Settings first!'); setGameState('settings'); return; }
                const exchangesRef = db.collection('exchanges');
                const userExchanges = await exchangesRef.where('userId', '==', user.uid).orderBy('timestamp', 'desc').limit(1).get();
                if (!userExchanges.empty) {
                    const lastExchange = userExchanges.docs[0].data();
                    const hoursSince = (Date.now() - lastExchange.timestamp.toMillis()) / (1000 * 60 * 60);
                    if (hoursSince < 24) { alert(`⏳ Exchange Limit Reached\n\nYou can only exchange once per 24 hours.\n\nNext exchange available in ${Math.ceil(24 - hoursSince)} hours.`); return; }
                }
                const mlxAmount = (mmlxBalance / exchangeRate).toFixed(6);
                const exchangeData = { userId: user.uid, username: user.username, mmlxAmount: mmlxBalance, mlxAmount: mlxAmount, mlxAddress: mlxAddress, tangledUsername: tangledUsername, timestamp: firebase.firestore.FieldValue.serverTimestamp(), processed: false };
                await exchangesRef.add(exchangeData);
                const newBalance = 0;
                setMmlxBalance(newBalance);
                await db.collection('users').doc(user.uid).update({ mmlxBalance: newBalance });
                try { await emailjs.send(EMAILJS_SERVICE_ID, EMAILJS_TEMPLATE_ID, { username: user.username, mmlx_amount: parseInt(mmlxBalance).toLocaleString(), mlx_amount: mlxAmount, tangled_username: tangledUsername || 'Not provided', mlx_address: mlxAddress || 'Not provided', date: new Date().toLocaleString() }, EMAILJS_PUBLIC_KEY); } catch (error) { console.error('Email failed:', error); }
                alert(`Exchange Submitted!\n\n${parseInt(mmlxBalance).toLocaleString()} MMLX = ${mlxAmount} MLX\n\nYou'll receive MLX within 24 hours.\n\nNext exchange available in 24 hours.`);
                setGameState('menu');
            };

            const savePaymentInfo = async () => {
                if (user) { await db.collection('users').doc(user.uid).update({ mlxAddress, tangledUsername }); setHint('Saved!'); setTimeout(() => setHint(''), 2000); }
            };

            if (showAd) return (<div className="min-h-screen bg-black bg-opacity-95 flex items-center justify-center p-4"><div className="bg-white rounded-2xl shadow-2xl p-8 max-w-md w-full text-center"><h2 className="text-2xl font-bold text-gray-800 mb-4">Advertisement</h2><div className="bg-gradient-to-br from-blue-500 to-purple-600 rounded-xl p-8 mb-4 min-h-[300px] flex flex-col items-center justify-center text-white shadow-2xl"><div className="text-6xl mb-2">🎮</div><p className="text-3xl font-bold mb-2">Play & Win!</p><p className="text-lg">Join 10M+ Players</p></div>{adCountdown > 0 && <div className="bg-gray-100 rounded-lg p-3 mb-4"><p className="text-sm text-gray-600">Wait <span className="font-bold text-purple-600">{adCountdown}</span> seconds...</p></div>}<button onClick={closeAdAndActivateRemoval} disabled={adCountdown > 0} className={`font-bold py-3 px-8 rounded-lg ${adCountdown > 0 ? 'bg-gray-300 text-gray-500' : 'bg-gradient-to-r from-purple-500 to-blue-500 text-white'}`}>{adCountdown > 0 ? `Wait ${adCountdown}s` : adPurpose === 'tileRemoval' ? 'Activate Removal' : adPurpose === 'earnCoins' ? `Claim ${mmlxPerAd} MMLX` : 'Continue'}</button></div></div>);

            if (gameState === 'login') return (<div className="min-h-screen bg-gradient-to-br from-purple-600 to-blue-600 flex items-center justify-center p-4"><div className="bg-white rounded-2xl shadow-2xl p-8 w-full max-w-md"><h1 className="text-4xl font-bold text-purple-600 mb-2 text-center">Mahjong MLX</h1><p className="text-gray-600 text-center mb-8">Play & Earn Crypto</p><div className="bg-gradient-to-r from-green-50 to-emerald-50 border-2 border-green-300 rounded-xl p-4 mb-6"><p className="text-sm font-bold text-green-800 mb-2">Get Paid in MLX</p><p className="text-xs text-gray-700 mb-3">Join Tangled.com to receive your cryptocurrency rewards!</p><a href="https://alexisread.tangled.com/join?l=en&s1=majong" target="_blank" rel="noopener noreferrer" className="block w-full bg-gradient-to-r from-green-500 to-emerald-600 text-white font-bold py-2 px-4 rounded-lg text-center hover:shadow-lg transition-all">Join Tangled.com FREE</a></div><div className="space-y-4"><input type="text" placeholder="Username" value={username} onChange={(e) => setUsername(e.target.value)} className="w-full border-2 rounded-lg px-4 py-3" /><input type="password" placeholder="Password" value={password} onChange={(e) => setPassword(e.target.value)} className="w-full border-2 rounded-lg px-4 py-3" /><button onClick={handleAuth} disabled={loading} className="w-full bg-gradient-to-r from-purple-500 to-blue-500 text-white font-bold py-3 rounded-lg">{loading ? 'Loading...' : isLogin ? 'Login' : 'Register'}</button><button onClick={() => setIsLogin(!isLogin)} className="w-full text-purple-600 text-sm">{isLogin ? "Register" : 'Login'}</button></div></div></div>);

            if (gameState === 'menu') return (<div className="min-h-screen bg-gradient-to-br from-purple-600 to-blue-600 p-4"><div className="max-w-md mx-auto">{completedLevels > 0 && !tangledUsername && !mlxAddress && !showTangledPrompt && <div className="bg-white rounded-2xl shadow-lg p-6 mb-4 border-4 border-green-400"><div className="text-center mb-4"><p className="text-2xl font-bold text-green-600 mb-2">Ready to Get Paid?</p><p className="text-gray-700 text-sm mb-1">You're earning MMLX tokens!</p><p className="text-gray-700 text-sm mb-4">Join Tangled.com to exchange them for real MLX cryptocurrency.</p></div><a href="https://alexisread.tangled.com/join?l=en&s1=majong" target="_blank" rel="noopener noreferrer" className="block w-full bg-gradient-to-r from-green-500 to-emerald-600 text-white font-bold py-3 px-4 rounded-lg text-center hover:shadow-lg transition-all mb-3">Join Tangled.com FREE</a><button onClick={() => setShowTangledPrompt(true)} className="w-full text-gray-500 text-sm hover:text-gray-700">Maybe later</button></div>}<div className="bg-white rounded-2xl shadow-lg p-6 mb-4"><a href="https://alexisread.tangled.com/join?l=en&s1=majong" target="_blank" rel="noopener noreferrer" className="block w-full bg-gradient-to-r from-green-500 to-emerald-600 text-white font-bold py-3 px-4 rounded-xl text-center hover:shadow-lg transition-all mb-4">JOIN TANGLED TO GET PAID</a><div className="flex items-center justify-between mb-4"><div><p className="text-sm text-gray-600">Welcome</p><p className="font-bold text-lg">{user?.username}</p></div><button onClick={() => { auth.signOut(); }} className="text-gray-400">Logout</button></div><div className="grid grid-cols-3 gap-4 text-center"><div className="bg-purple-50 rounded-lg p-3"><p className="text-2xl font-bold text-purple-600">{mmlxBalance.toLocaleString()}</p><p className="text-xs text-gray-600">MMLX</p></div><div className="bg-blue-50 rounded-lg p-3"><p className="text-2xl font-bold text-blue-600">{level}</p><p className="text-xs text-gray-600">Level</p></div><div className="bg-green-50 rounded-lg p-3"><p className="text-2xl font-bold text-green-600">{completedLevels}</p><p className="text-xs text-gray-600">Done</p></div></div></div><button onClick={startLevel} className="w-full bg-gradient-to-r from-purple-500 to-blue-500 text-white rounded-2xl shadow-lg p-6 mb-4"><p className="text-2xl font-bold">Play Level {level}</p><p className="text-sm mt-1">Earn {(1000 + level * 100).toLocaleString()}+ MMLX</p></button><div className="grid grid-cols-2 gap-4"><button onClick={() => setGameState('wallet')} className="bg-white rounded-xl shadow p-4">Exchange</button><button onClick={() => setGameState('settings')} className="bg-white rounded-xl shadow p-4">Settings</button></div></div></div>);

            if (gameState === 'playing') return (<div className="min-h-screen bg-gradient-to-br from-amber-100 to-amber-200 p-2"><div className="max-w-4xl mx-auto"><div className="bg-white rounded-xl shadow p-3 mb-3 flex justify-between items-center flex-wrap gap-2"><div className="flex gap-3 items-center"><span className="font-bold">{elapsedTime}s</span><span className="text-purple-600">{tiles.filter(t => !t.matched).length} tiles</span></div><div className="flex gap-2"><button onClick={watchAdForCoins} disabled={adForCoinsUsed} className={`px-4 py-2 rounded-lg font-bold text-white text-sm ${adForCoinsUsed ? 'bg-gray-400' : 'bg-green-500'}`}>{adForCoinsUsed ? 'Used' : `+${mmlxPerAd}`}</button><button onClick={watchAdForRemoval} disabled={adRemovalCooldown > 0 || adRemovalsUsed >= maxAdRemovalsPerLevel} className={`px-4 py-2 rounded-lg font-bold text-white text-sm ${isRemovalMode ? 'bg-red-500' : adRemovalCooldown > 0 || adRemovalsUsed >= maxAdRemovalsPerLevel ? 'bg-gray-400' : 'bg-orange-500'}`}>{isRemovalMode ? 'SELECT' : adRemovalCooldown > 0 ? `${adRemovalCooldown}s` : `Remove (${adRemovalsUsed}/${maxAdRemovalsPerLevel})`}</button></div><button onClick={() => setGameState('menu')} className="bg-red-500 text-white px-3 py-1 rounded">Quit</button></div>{hint && <div className="bg-yellow-100 rounded-xl p-3 mb-3 text-center"><p className="font-bold text-yellow-700">{hint}</p></div>}<div className="bg-gradient-to-br from-amber-700 to-amber-900 rounded-xl p-4 flex items-center justify-center" style={{minHeight:'400px'}}><div style={{position:'relative',width:'650px',height:'450px'}}>{tiles.map(tile => { const blocked = isTileBlocked(tile, tiles); const selected = selectedTiles.find(t => t.id === tile.id); const willBeRemoved = removalPreview.includes(tile.id); return (<div key={tile.id} className={`tile-3d ${tile.matched?'tile-matched':''} ${blocked && !isRemovalMode?'tile-blocked':''} ${isRemovalMode ? 'tile-removal-mode' : ''}`} style={{left:`${tile.x*45+tile.z*2}px`,top:`${tile.y*45+tile.z*2}px`,zIndex:tile.z*100+tile.y*10+tile.x,width:'45px',height:'45px'}} onClick={() => !tile.matched && selectTile(tile)} onMouseEnter={() => !tile.matched && isRemovalMode && handleRemovalHover(tile)} onMouseLeave={() => setRemovalPreview([])}><div className={`tile-face ${selected?'tile-selected':''} ${willBeRemoved?'tile-will-remove':''}`} style={{width:'100%',height:'100%',fontSize:'1.75rem'}}>{tile.type}</div></div>); })}</div></div></div></div>);

            if (gameState === 'wallet') return (<div className="min-h-screen bg-gradient-to-br from-purple-600 to-blue-600 p-4"><div className="max-w-md mx-auto"><button onClick={() => setGameState('menu')} className="text-white mb-4">Back</button><div className="bg-white rounded-2xl p-6"><h2 className="text-2xl font-bold text-purple-600 mb-4">Exchange</h2><div className="bg-yellow-100 rounded-xl p-4 mb-4"><p className="text-3xl font-bold text-yellow-700">{mmlxBalance.toLocaleString()} MMLX</p><p className="text-gray-700 text-lg mt-1">= {(mmlxBalance/exchangeRate).toFixed(6)} MLX</p></div>{(!mlxAddress && !tangledUsername) && <div className="bg-orange-50 border-2 border-orange-300 rounded-lg p-4 mb-4"><p className="text-orange-800 font-bold mb-2">Action Required</p><p className="text-sm text-orange-700">Add payment info in Settings!</p><button onClick={() => setGameState('settings')} className="mt-2 bg-orange-500 text-white px-4 py-2 rounded-lg text-sm font-bold">Go to Settings</button></div>}<button onClick={handleExchange} disabled={mmlxBalance < 10000} className={`w-full py-3 rounded-xl font-bold text-white ${mmlxBalance >= 10000 ? 'bg-green-500' : 'bg-gray-400'}`}>{mmlxBalance >= 10000 ? 'Submit Exchange' : 'Need 10,000 MMLX'}</button></div></div></div>);

            if (gameState === 'settings') return (<div className="min-h-screen bg-gradient-to-br from-purple-600 to-blue-600 p-4"><div className="max-w-md mx-auto"><button onClick={() => setGameState('menu')} className="text-white mb-4">Back</button><div className="bg-white rounded-2xl p-6 max-h-[calc(100vh-100px)] overflow-y-auto"><h2 className="text-2xl font-bold text-purple-600 mb-4">Settings</h2><div className="border-2 border-blue-300 rounded-lg p-4 bg-blue-50"><label className="block mb-2 text-sm font-bold">Tangled.com Username</label><input type="text" value={tangledUsername} onChange={(e)=>setTangledUsername(e.target.value)} placeholder="username" className="w-full border-2 rounded-lg px-4 py-2 mb-3" /><label className="block mb-2 text-sm font-bold">OR MLX Address</label><input type="text" value={mlxAddress} onChange={(e)=>setMlxAddress(e.target.value)} placeholder="MLX1..." className="w-full border-2 rounded-lg px-4 py-2 mb-3" /><button onClick={savePaymentInfo} className="w-full bg-blue-600 text-white py-2 rounded-lg font-bold">Save Payment Info</button></div>{hint && <div className="mt-4 text-center text-green-600 font-bold">{hint}</div>}</div></div></div>);

            return null;
        };

        ReactDOM.render(<MahjongMLX />, document.getElementById('root'));
    </script>
</body>
</html>
